<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Anaconda中为每个项目创建新环境</title>
    <url>/2020/12/04/Anaconda%E4%B8%AD%E4%B8%BA%E6%AF%8F%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E6%96%B0%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="创建新环境"><a href="#创建新环境" class="headerlink" title="创建新环境"></a>创建新环境</h1><p>进入cmd，进入anaconda所在的文件夹位置（如：D:\Software\Anaconda\envs）</p>
<a id="more"></a>

<p>依次输入：</p>
<p><code>conda create --name 项目名称 python=版本号</code></p>
<p><code>activate</code></p>
<p><code>conda activate 项目名称</code>   切换不同环境的时候也使用该语句</p>
<p>然后使用pip install安装所需包即可。</p>
<hr>
<h1 id="查看环境"><a href="#查看环境" class="headerlink" title="查看环境"></a>查看环境</h1><ul>
<li>查看目前已安装的环境：<code>conda info --envs</code></li>
<li>查看环境下已安装的包：<code>pip list</code></li>
</ul>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>在markdown中插入图片</title>
    <url>/2020/12/02/markdown%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="在markdown文件中插入图片"><a href="#在markdown文件中插入图片" class="headerlink" title="在markdown文件中插入图片"></a>在markdown文件中插入图片</h1><p>　　这里选择采用将图片上传到GitHub上的方法进行图片的插入。具体步骤如下：</p>
<p>　　<a id="more"></a></p>
<p>　　1.登录GitHub,创建一个新仓库用来存放图片，如下图所示：<div align=center><img src="http://jiajunjun.top/md_picture/test_pic1.png" alt="图1"></div></p>
<p>　　2.在本地磁盘中新建一个存放图片的文件夹，然后把需要插入的图片放入该文件夹中。</p>
<p>　　3.在该文件夹下打开Git Bash。</p>
<p>　　4.配置自己的身份：依次输入 </p>
<p>　　<code>git config --global user.name &quot;Your name&quot;</code> </p>
<p>　　<code>git config --global user.email &quot;Your email&quot;</code></p>
<p>　　5.创建代码仓库：</p>
<p>　　<code>git init</code>：此时本地仓库就有一个.git的隐藏文件夹</p>
<p>　　6.提交本地代码：</p>
<p>　　<code>git add .</code> ：把所有文件添加到仓库</p>
<p>　　<code>git commit -m &quot;xxx&quot;</code>：把文件提交到仓库，xxx可以输入本次提交的说明</p>
<p>　　如下图所示：<br>　　<br>　　<div align=center><img src="http://jiajunjun.top/md_picture/test_pic2.png" alt="图2"></div></p>
<p>　　7.把本地仓库关联到GitHub上的远程库：</p>
<p>　　<code>git remote add origin git@github.com:your username/repositories name.git</code>：注意要将your username改成你自己的GitHub账户名，repositories name改成仓库名。</p>
<p>　　8.把本地库的内容推送到远程：</p>
<p>　　<code>git push -u origin master</code></p>
<p>　　此时本地库和远程库的内容就已经一样了。</p>
<p>　　9.打开在GitHub上创建的仓库，进入Settings，下拉找到GitHub Pages，将Source中的None改为master，点击save保存。如下图所示：<div align=center><img src="http://jiajunjun.top/md_picture/test_pic3.png" alt="图3"></div></p>
<p>　　10.此时图片在网络上的地址为GitHub项目地址加图片名，例如我这里的图片地址为：<a href="https://jiajunjun.github.io/md_picture/pic1.png">https://jiajunjun.github.io/md_picture/pic1.png</a></p>
<p>　　11.在markdown文件中插入图片：</p>
<p>　　<code>![图片名称](https://jiajunjun.top/md_picture/pic1.png)</code></p>
<p>　　如果还不能显示，将https://改为http://即可</p>
<p>　　<div align=center><img src="http://jiajunjun.top/md_picture/pic1.png" alt="pic1"></div></p>
<p>　　12.之后如果想要再插入新的图片时，可以在本地库中添加图片，然后在本地库的文件夹下打开Git Bash，然后依次输入：</p>
<p>　　<code>git add .</code></p>
<p>　　<code>git commit -m &quot;xxxx&quot;</code></p>
<p>　　<code>git push origin master</code></p>
<p>　　之后按上述方法在markdown文件中插入图片即可。</p>
]]></content>
      <categories>
        <category>TIPS</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>文献阅读：Understanding Dropouts in MOOCs</title>
    <url>/2020/12/01/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p><strong>objective：</strong></p>
<p>　　MOOCs有极高的辍学率，完成率低于5% 。本文研究导致用户退出的主要因素，用户在MOOCs学习的主要动机。</p>
<a id="more"></a>

<p><strong>methods：</strong></p>
<p>　　将用户的学习行为分成几个不同的类别。揭示不同课程的辍学者之间的高度相关性以及朋友辍学行为之间的强烈影响。在此基础上，提出了一个上下文感知的特征交互网络(CFIN)来建模和预测用户的退出行为。CFIN利用上下文平滑技术平滑不同上下文的特征值，并利用注意机制将用户和课程信息结合到建模框架中。</p>
<p><strong>results：</strong></p>
<p>　　CFIN比现有的几种方法具有更好的性能。所提出的方法模型已经在实际系统上部署，以帮助提高用户保留率。</p>
<hr>
<h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><p>　　KDDCUP、XuetangX</p>
<hr>
<h1 id="Insights"><a href="#Insights" class="headerlink" title="Insights"></a>Insights</h1><h2 id="Temporal-Code"><a href="#Temporal-Code" class="headerlink" title="Temporal Code"></a>Temporal Code</h2><p>　　Suc:学生u和登记的课程c，时间代码是一个二值向量，每个值表示用户u在第k周是否访问课程c。</p>
<p>　　Su:学生u的每一项课程在每周的访问情况</p>
<h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><p>　　将所有用户时间编码的稀疏表示输入到K-means算法中。</p>
<p>　　通过Silhouette Analysis(1987)，集群的数量被设置为5。</p>
<h2 id="相关性"><a href="#相关性" class="headerlink" title="相关性"></a>相关性</h2><ul>
<li><strong>课程之间的相关性（回归分析）：</strong></li>
</ul>
<p>　　方法：用户在课程中的退学行为被编码为16-dim虚拟向量，每个元素表示用户在相应的一周内是否访问过该课程(因此16对应学习该课程的16周)。回归模型的输入和输出是两个虚拟向量，表示用户在同一学期中对两门不同课程的退学行为。</p>
<p>　　结果：同一类别的课程之间的相关性要高于不同类别的课程。一种可能的解释是，当用户学习MOOC的时间有限时，他们可能会首先放弃自己的课程，而选择补充知识领域的课程。</p>
<ul>
<li><strong>辍学朋友的影响（基于网络）：</strong></li>
</ul>
<p>　　方法：建立用户-课程图，节点是用户和课程，边是代表参加了课程。用随机游走算法为图中的每个用户和每个课程进行低维表示。计算了选修同一门课程的用户间的余弦相似度。相似度大于0.8视为好友。</p>
<p>　　结果:结果表明用户的退学率很大程度上受到其朋友的退学行为的影响</p>
<hr>
<h1 id="CFIN算法"><a href="#CFIN算法" class="headerlink" title="CFIN算法"></a>CFIN算法</h1><h2 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h2><ul>
<li><p><strong>Enrollment Relation（登记关系）：</strong> U,C,E</p>
</li>
<li><p><strong>Learning Activity（学习活动）：</strong>X（u,x）</p>
</li>
<li><p><strong>Context Information（上下文信息）：</strong>Z（u,c）包括用户信息（性别，年龄，位置，学历信息，用户聚类）和课程信息（课程类别）</p>
</li>
</ul>
<h2 id="目标问题"><a href="#目标问题" class="headerlink" title="目标问题"></a>目标问题</h2><p>　　给定用户u在之前的关于课程c的学习活动<strong>X(u，c)**和上下文信息</strong>Z(u,c)**，判断用户在perdiction period是否有学习活动，用y(u,c)表示。</p>
<h2 id="Context-aware-Feature-Interaction-Network（感知上下文的特征交互网络）"><a href="#Context-aware-Feature-Interaction-Network（感知上下文的特征交互网络）" class="headerlink" title="Context-aware Feature Interaction Network（感知上下文的特征交互网络）"></a>Context-aware Feature Interaction Network（感知上下文的特征交互网络）</h2><ul>
<li><strong><em>Motivation</em>:</strong></li>
</ul>
<p>　　上下文平滑：使用卷积神经网络(CNN)通过利用上下文统计来学习每个活动特征**xi(u, c)**的上下文感知表示</p>
<p>　　注意机制：通过将*<em>Z(u, c)**</em>纳入到退学预测中，来学习不同活动的重要性。</p>
<ul>
<li><strong><em>上下文平滑策略</em>:</strong></li>
</ul>
<p>　　三个步骤：特征增强、嵌入和特征融合。</p>
<pre><code>+ **特征增强：** **xi（u，c)**加上用户u对所有课程的统计信息，和课程在所有用户上的统计信息。

+ **嵌入：****xi**通过嵌入层转化为稠密向量,乘以参数a表示嵌入向量。

+ **特征融合：**将嵌入矩阵Egi通过CNN变成一个向量,Vgi=σ（Wδ(Egi)+b)

**每个特征组Xgi都被一个稠密向量Vgi表示，它可以被看作是每个xi的上下文感知的表示，并集成了其上下文统计信息。**</code></pre>
<ul>
<li><strong><em>注意机制</em>:</strong></li>
</ul>
<p>　　将Z的嵌入矩阵Ez输入到全连通层中，将Z转换为密集向量Vz：Vz=σ（Wδ(Ez)+b)</p>
<p>　　使用Vz计算每个Vgi的注意力分数λi</p>
<p>　　得到λi*Vgi的加权和Vg sum,作为X(u,c)的上下文感知表示</p>
<p>　　将Vg sum放入l层的DNN中学习特征间的相互作用，最后用sigmoid函数预测</p>
<h2 id="Model-Ensemble（模型集成）"><a href="#Model-Ensemble（模型集成）" class="headerlink" title="Model Ensemble（模型集成）"></a>Model Ensemble（模型集成）</font></h2><p><strong>xgboost结合CFIN</strong></p>
<hr>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>　　使用TensorFlow实现CFIN，采用Adam对模型进行优化。为了避免过拟合，对权值矩阵应用l2正则化。采用直线直线单元(Relu)作为激活函数。所有特性在输入到CFIN之前都经过了标准化。</p>
<p>　　在KDDCUP和XuetangX数据集上测试了CFIN的性能。对于KDDCUP数据集，比赛组织者将历史周期和预测周期分别设置为30天和10天。没有对该数据使用CFIN的注意机制，因为数据集中没有提供上下文信息。对于XuetangX数据集，历史周期设置为35天，预测周期设置为10天，即Dh=35, Dp=10</p>
<h2 id="对比算法"><a href="#对比算法" class="headerlink" title="对比算法"></a>对比算法</h2><ul>
<li> LR</li>
<li> SVM</li>
<li> RF</li>
<li> GBDT</li>
<li> DNN</li>
<li> CFIN</li>
<li> CFIN-en</li>
</ul>
<p>　　基于网格搜索的5次交叉验证(CV)调整参数，并在所有实验中使用最优的参数组。评价指标包括 AUC和F1。</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><ul>
<li>预测结果</li>
</ul>
<p>　　CFIN-en在两个数据集上的表现都是最好的，在KDDCUP数据集上AUC得分达到90.93%，CFIN也表现出更好的性能。</p>
<ul>
<li>特征贡献</li>
</ul>
<p>　　对三个主要活动特征进行了特征消融实验，即视频活动、任务活动和论坛活动。具体来说，我们首先将所有特性输入到CFIN，然后逐个删除每种类型的活动特性，以观察性能的变化。</p>
<p>　　结果表示，这三种活动在这个任务中都是有用的。在KDDCUP上，作业是最重要的，而在XuetangX上，视频是最重要的。</p>
<ul>
<li>不同用户组的不同特性的细粒度分析</li>
</ul>
<p>　　五组群体的注意权重分布有很大的不同</p>
]]></content>
      <categories>
        <category>文献阅读</category>
      </categories>
      <tags>
        <tag>教育数据挖掘</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的使用</title>
    <url>/2020/12/15/git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><ul>
<li>创建空目录：<code>mkdir xxxxx（文件夹名）</code></li>
<li>创建仓库：<code>git init</code></li>
</ul>
<p>　　使用Notepad++创建一个.txt文件并保存到刚刚文件夹下，如readme.txt</p>
<a id="more"></a>

<ul>
<li>将文件添加到仓库：<code>git add readme.txt</code></li>
<li>把文件提交到仓库：<code>git commit -m &quot;xxxxx&quot;</code>（-m后面输入的是本次提交的说明，这样就能从历史记录里方便地找到改动记录。）</li>
</ul>
<p>　　git commit命令执行成功后如下图：</p>
<p><img src="http://jiajunjun.top/md_picture/usegit1.png" alt="git commit命令执行成功"></p>
<p>　　(1 file changed：1个文件被改动（新添加的readme.txt文件）; 2 insertions：插入了两行内容（readme.txt有两行内容）)</p>
<p>　　commit可以一次提交多个文件，所以可以多次add再commit。</p>
<p><img src="http://jiajunjun.top/md_picture/usegit2.png" alt="git commit命令执行成功"></p>
<ul>
<li>查看仓库当前的状态：<code>git status</code></li>
</ul>
<p>　　例如：当对readme.txt进行修改后，输入git status。输出表明修改过但没提交。<br><img src="http://jiajunjun.top/md_picture/usegit3.png" alt="git commit命令执行成功"></p>
<ul>
<li><p>查看修改的内容：<code>git diff</code>。可以看到绿色字体与红色字体的对比，添加了distributed。<br><img src="http://jiajunjun.top/md_picture/usegit4.png" alt="git commit命令执行成功"></p>
</li>
<li><p>进行提交：<code>git add readme.txt</code></p>
</li>
<li><p><code>git commit -m &quot;add distributed&quot;</code></p>
</li>
<li><p>查看此时仓库的状态： <code>git status</code> (显示 nothing to commit,working tree clean，表明当前没有需要提交的修改，而且工作目录是干净的。)</p>
</li>
<li><p>查看提交日志：<code>git log(完整版）</code> (<code>git log --pretty=oneline</code>(精简版）)</p>
</li>
</ul>
<h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><ul>
<li><p>回退到上一个版本：<code>git reset --hard HEAD^</code> (文件已经被修改回上一个版本，若想回到上上个版本，用HEAD^^，若想回到往上100个版本，用HEAD~100)</p>
</li>
<li><p>又想回到刚刚最新的版本：git reset –hard 6d1fe (从命令行往上翻，找到最新版本前边的commit id，输入前几位就OK了，这里最新版本的commit id 是 6d1fe770…）</p>
</li>
<li><p>如果忘记commit id：git reflog（可以查看之前的每一次命令，可以找到每一次命令的commit id )</p>
</li>
</ul>
<h1 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h1><p><img src="http://jiajunjun.top/md_picture/usegit5.png" alt="git commit命令执行成功"></p>
<p>　　git add 实际上是把文件修改添加到暂存区（图中的stage)，git commit 实际上是把暂存区中的所有内容提交到当前分支（master是Git自动创建的第一个分支）。所以commit可以一次性提交多个文件。如果修改readme.txt文件，并且新建了一个LICENSE文件，此时若执行完git add readme.txt和git add LICENSE后，暂存区的状态如下图：</p>
<p><img src="http://jiajunjun.top/md_picture/usegit6.png" alt="git commit命令执行成功"></p>
<p>　　此时执行git commit后，就变成了下图，暂存区没有任何内容，commit将两个文件全部提交。</p>
<p><img src="http://jiajunjun.top/md_picture/usegit7.png" alt="git commit命令执行成功"></p>
<h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><ul>
<li><p>文件提交前，可手动修改到之前的状态，也可使用 <code>git checkout -- readme.txt</code> ，将readme.txt文件在工作区的修改撤销，回退到最近一次 git commit 或 git add 的状态。</p>
</li>
<li><p>文件已经add，但未commit：<code>git reset HEAD readme.txt</code>，回退版本，把暂存区的修改退回到工作区。</p>
</li>
</ul>
<h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><ul>
<li><code>rm test.txt</code><ul>
<li>确实要删除：<code>git rm test.txt</code><br>　<code>git commit -m &quot;xxxxx&quot;</code></li>
<li>删错了：<code>git checkout -- test.txt</code>
　　　　</li>
</ul>
</li>
</ul>
<h1 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h1><ul>
<li><p>在GitHub中新建一个仓库后，在本地仓库下运行：<code>git remote add origin git@github.com:JiaJunJun/learngit.git</code></p>
</li>
<li><p>第一次推送master分支的所有内容：<code>git push -u origin master</code></p>
</li>
<li><p>之后提交：<code>git push origin master</code></p>
</li>
</ul>
<p>　　本地仓库与远程仓库同步</p>
<ul>
<li>把远程仓库克隆到本地：github中新建仓库newlocal，在本地想要位置下输入命令：<code>git clone git@github.com:JiaJunJun/newlocal.git</code></li>
</ul>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><ul>
<li><p>查看分支：<code>git branch</code></p>
</li>
<li><p>创建分支：<code>git branch &lt;name&gt;</code></p>
</li>
<li><p>切换分支：<code>git checkout &lt;name&gt;</code> 或 <code>git switch &lt;name&gt;</code></p>
</li>
<li><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code> 或 <code>git switch -c &lt;name&gt;</code></p>
</li>
<li><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
</li>
<li><p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
</li>
</ul>
<p>参考链接：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
